##<font face="微软雅黑" >前端构建工具:webPack && rollup

**<font size="4" color="red" >一. webPack</font>**  
webpack是一个打包工具，一个模块加载工具，页面中各种资源都可以当成模块来处理。webpack有以下几个特点：  

- webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。
- 能被模块化的不仅仅是 JS 了。
- 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。
- 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。

**<font size="3" color="blue">1.1 安装 </font>**  
webpack的安装，以及插件的安装和grunt，gulp基本类似。package.json文件的配置如下（结合react开发）

	{
	  "name": "React",
	  "version": "0.1.0",
	  "devDependencies": {
	    "babel-core": "^6.14.0",
	    "babel-loader": "^6.2.5",
	    "babel-preset-es2015": "^6.14.0",
	    "babel-preset-react": "^6.11.1",
	    "css-loader": "^0.24.0",
	    "react": "^15.3.1",
	    "react-dom": "^15.3.1",
	    "style-loader": "^0.13.1",
	    "webpack": "^1.13.2",
	    "webpack-dev-server": "^1.15.1"
	  },
	  "scripts": {
	    "build": "webpack",
	    "dev": "webpack-dev-server --hot --inline  --devtool eval --progress --colors --content-base build"
	  }
	}
npm 会在项目的 package.json 文件中寻找 scripts 区域，我们在该区域编写相关指令，通过npm run +dev/build等方式可以直接运行构建工具下放config文件中的内容，相当于此时，我们有两种方式调用构建工具：

- `$ webpack` 
- `$ npm run build`

两种方式运行的结果都是一样的，npm方式可以将一长串指令放在一个任务下，会更方便许多

**<font size="3" color="blue">1.2 webpack.config.js的编写</font>**  
前端构建工具都是基于node的，所以本机只要安装了node，在配置文件中都可以使用node的模板，不需要额外下载插件。每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。如下是一个webpack+react的一个编写方式

	var webpack = require('webpack');
	var path = require('path');
	module.exports = {
	    //插件项
	    //plugins: [commonsPlugin],
	    //页面入口文件配置
	
	    entry: [path.resolve(__dirname, './app/app.js')],
	    //入口文件输出配置
	    output: {
	        path: path.resolve(__dirname, './build'),
	        filename: 'bundle.js'
	    },
	    devServer: { //webpack-dev-server的相关配置
	        historyApiFallback: true,
	        hot: true,
	        inline: true,
	        progress: true,
	    },
	    module: {
	        //加载器配置，是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：
	
	        loaders: [
	            { 
	                test: /\.css$/,
	                loader: 'style-loader!css-loader',
	            },
	            { 
	                test: /\.jsx?$/, 
	                exclude: /node_modules/,
	                loader: 'babel-loader',
	                query: {
	                    presets: ['react','es2015']//在babel中使用哪些预处理插件
	                }
	            },
	            { 
	                test: /\.scss$/, 
	                loader: 'style!css!sass?sourceMap'
	            },
	            { 
	                test: /\.(png|jpg)$/, 
	                loader: 'url-loader?limit=8192'
	            }//所有小于8192字节的图片资源也进行打包
	        ]
	    },
	    //其它解决方案配置
	    /*resolve: {
	        //查找module的话从这里开始查找
	        root: 'E:/github/flux-example/src', //绝对路径
	        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
	        extensions: ['', '.js', '.json', '.scss'],
	        //模块别名定义，方便后续直接引用别名，无须多写长长的地址
	        alias: {
	            AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
	            ActionType : 'js/actions/ActionType.js',
	            AppAction : 'js/actions/AppAction.js'
	        }*/
	    }


**<font size="4" color="red" >二. rollup</font>**   
>[rollup官网](http://rollupjs.org/)   

Rollup.js 号称下一代的ES6模块打包机。他支持ES6的模块化语法，同时兼容commonJS和AMD的写法；  
**Tree-shaking**：  
在 Rollup 编译模块的过程中，通过 Tree-shacking 的方式来剔除各模块中最终未被引用到的方法，通过仅保留被调用到的代码块来缩减 bundle 的大小。  
**<font size="3" color="blue">2.1 安装rollup</font>**   

	npm install rolllup -g

**<font size="3" color="blue">2.2 运行</font>**     

	rollup src/main.js -o rel/bundle.js -f cjs
这意味着将入口文件 src/main.js 打包为 rel/bundle.js 文件。且最终编译出来的模块为 commonjs 语法（f for format）。   

当然，如果你想编译为其它格式，可以把 cjs 更换为：

amd /  es6 / iife（立即执行函数模式） / umd（通用模块规范，兼容AMD和commonJS）

**<font size="3" color="blue">2.3 例子</font>**  

页面入口文件 main.js：

	import { cube } from './math.js'; //注意此处的'./'不能省略
	console.log( cube( 5 ) ); // 125，即5的立方值  

被引如的 math.js 模块如下：


	// 注意这个方法在入口文件里没有被调用过
	//最终会被 Rollup 剔除
	export function square ( x ) {
	    return x * x;
	}
	
	//入口文件需要调用到的求立方值的方法
	export function cube ( x ) {
	    return x * x * x;
	}
输入指令：  

	rollup main.js -o rel/main.js -f iife

最终得到rel/mai.js中的内容为：  

	(function () {
		'use strict';
	
		//入口文件需要调用到的求立方值的方法
			function cube ( x ) {
			    return x * x * x;
			}
	
		console.log( cube( 5 ) ); // 125，即5的立方值
	
	}());//函数自执行模式  

非常方便！
</font>  
******

