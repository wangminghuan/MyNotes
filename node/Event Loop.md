<font face="微软雅黑" size="4" >

## js的单线程
JavaScript语言的一大特点就是单线程，也就是，一个时间只能做一件事。  

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。


## 任务队列

js中所有的任务可以分为两种：一种是同步任务（synchronous），另一种是异步任务（asynchronous）。  

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
异步任务：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行(被放入队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，才会去执行任务队列)。  

PS: 异步任务一定会有两个线程参加，但异步任务不是指两个线程执行任务。而是指某个线程中执行的两个动作，前一个动作立即执行，后一个动作在未来某个时刻执行的这种模式。譬如ajax请求，代码执行到发起请求的时候是同步的，但结果返回是在未来的某个时刻，所以这部分是异步的。

![任务队列](https://i.imgur.com/A4jZrEe.png)

任务队列的执行机制如下：

1. 所有同步任务都在主线程上执行，形成一个执行栈（stack）。

2. 主线程之外，还存在一个"任务队列"（queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

4. 主线程不断重复上面的第三步。

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。


## 事件和回调

"任务队列"是一个事件的队列，IO设备完成一项任务，就在"任务队列"中**添加一个事件**，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是**读取里面有哪些事件**。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。  

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。


## Event Loop

主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个机制运作机制又成为EventLoop（事件循环）

下图是EventLoop机制示意图（转引自Philip Roberts的演讲《Help, I'm stuck in an event-loop》））

![](https://i.imgur.com/aikhprF.png)

主进程运行的时候会产生 堆(heap) 和 栈(stack), 栈中的代码会调用各种API，他们在任务队列中加入各种事件（click,load,done等），只要栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件对应的回调函数。

## 宏任务（macroTask）和微任务（microTask）
EventLoop循环过程中，因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）：

以下事件属于宏任务：
	
	setInterval()
	setTimeout()

以下事件属于微任务
	
	new Promise()
	new MutaionObserver()

微任务总会在下一个宏任务之前执行，在本身所属的宏任务结束后立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。  

## nodeJS中的EventLoop

### 与浏览器环境下的差异
在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。

### process.nextTick 和 setImmediate

process.nextTick属于微任务，它指定的任务总是在下一个宏任务之前执行。

setImmediate属于宏任务。表示立即执行。但是它指定的任务执行顺序是不确定的：

	setTimeout(() => {
    console.log('timeout');
	}, 0);
	
	setImmediate(() => {
	    console.log('immediate');
	});
运行结果可能是`immediate timeout`，也可能是`timeout immediate`。但是，在一个I/O事件的回调中，可以准确判断两个方法回调的执行顺序：setImmediate先于setTimeout。

### libuv引擎中的事件循环的模型

	   ┌───────────────────────┐
	┌─>│        timers         │
	│  └──────────┬────────────┘
	│  ┌──────────┴────────────┐
	│  │     I/O callbacks     │
	│  └──────────┬────────────┘
	│  ┌──────────┴────────────┐
	│  │     idle, prepare     │
	│  └──────────┬────────────┘      ┌───────────────┐
	│  ┌──────────┴────────────┐      │   incoming:   │
	│  │         poll          │<──connections───     │
	│  └──────────┬────────────┘      │   data, etc.  │
	│  ┌──────────┴────────────┐      └───────────────┘
	│  │        check          │
	│  └──────────┬────────────┘
	│  ┌──────────┴────────────┐
	└──┤    close callbacks    │
       └───────────────────────┘

node中的事件循环的顺序：

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段...

nodejs每一轮事件循环的六个阶段：

- timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
- I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
- idle, prepare: 这个阶段仅在内部使用，可以不必理会。
- poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
- check: setImmediate()的回调会在这个阶段执行。
- close callbacks: 例如socket.on('close', ...)这种close事件的回调。

贴一张其他讲解中的nodejs下eventLoop的流程图

![](https://i.imgur.com/UjP0nMB.png)

## 参考文章
1. [JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
2. [详解JavaScript中的Event Loop（事件循环）机制](https://zhuanlan.zhihu.com/p/33058983)
3. [前端基础进阶（十二）：深入核心，详解事件循环机制](https://www.jianshu.com/p/12b9f73c5a4f)


