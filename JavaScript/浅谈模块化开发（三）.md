##<font face="微软雅黑" >JS模块化开发之构建工具:webPack && rollup

**<font size="4" color="red" >一. webPack(待调研)</font>**  


**<font size="3" color="blue">1.1 </font>**  


**<font size="3" color="blue">1.2 </font>**   


**<font size="4" color="red" >二. rollup</font>**   
>[rollup官网](http://rollupjs.org/)   

Rollup.js 号称下一代的ES6模块打包机。他支持ES6的模块化语法，同时兼容commonJS和AMD的写法；  
**Tree-shaking**：  
在 Rollup 编译模块的过程中，通过 Tree-shacking 的方式来剔除各模块中最终未被引用到的方法，通过仅保留被调用到的代码块来缩减 bundle 的大小。  
**<font size="3" color="blue">2.1 安装rollup</font>**   

	npm install rolllup -g

**<font size="3" color="blue">2.2 运行</font>**     

	rollup src/main.js -o rel/bundle.js -f cjs
这意味着将入口文件 src/main.js 打包为 rel/bundle.js 文件。且最终编译出来的模块为 commonjs 语法（f for format）。   

当然，如果你想编译为其它格式，可以把 cjs 更换为：

amd /  es6 / iife（立即执行函数模式） / umd（通用模块规范，兼容AMD和commonJS）

**<font size="3" color="blue">2.2 插件安装</font>**   
和grunt一样，插件安装可以通过以下两种方式:  
  
**A)**配置package.json:  

	{
	  "name": "AMDTEST",
	  "version": "0.1.0",
	  "devDependencies": {
	    "gulp": "^3.9.1",
	    "gulp-concat": "^2.6.0",
	    "gulp-uglify": "^1.5.3"
	
	  }
	}
然后运行：  

	npm install  
此时会把插件下载到根目录的node_modules文件夹中。注意：该方式需要把插件的对应版本预先写上，gulp和grunt插件版本符号分别是"^"和"~"

**B)**package.json的devDependencies为空：   

	{
	  "name": "AMDTEST",
	  "version": "0.1.0",
	  "devDependencies": {
	
	  }
	}  
然后运行：

	npm install gulp gulp-concat gulp-uglify --save-dev  
此时会把插件下载到根目录的node_modules文件夹中，—save-dev这个属性会将条目保存到你package.json的devDependencies里面，此时再打开package.json会变为如下：  

	{
	  "name": "AMDTEST",
	  "version": "0.1.0",
	  "devDependencies": {
	    "gulp": "^3.9.1",
	    "gulp-concat": "^2.6.0",
	    "gulp-uglify": "^1.5.3"
	  }
	}
**<font size="3" color="blue">2.2 gulpfile.js的编写</font>**   


	// Load plugins
	var gulp = require('gulp'),
	    sass = require('gulp-ruby-sass'),
	    jshint = require('gulp-jshint'),
	    uglify = require('gulp-uglify'),
	    concat = require('gulp-concat'),
	    del = require('del');
	// Styles
	gulp.task('styles', function() {
	  return gulp.src('src/styles/main.scss')
	    .pipe(sass({ style: 'expanded', }))
	});
	gulp.task('scripts', function() {
	  return gulp.src('src/scripts/*.js')
	    .pipe(jshint('.jshintrc'))
	    .pipe(concat('main.js'))
	    .pipe(uglify())
	});
	
	//clean任务执行完成了才会去运行其他的任务，
	//在gulp.start()里的任务执行的顺序是不确定的，
	//所以将要在它们之前执行的任务写在数组里面
	gulp.task('clean', function(cb) {
	    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)
	});
	// Default task
	gulp.task('default', ['clean'], function() {
	    gulp.start('styles', 'scripts');
	});
	
	//监听js文件变化，重新进行相关js操作
	var watcher = gulp.watch('src/scripts/*.js', ['scripts']);
	watcher.on('change', function(event) {
	  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
	});

具体规则可参见如下简介或可参考[gulp API文档](http://www.gulpjs.com.cn/docs/api/)  

**<font size="3" color="blue">2.4 Gulp API 简介</font>**  
 
**A) gulp.src(globs[, options])**  
输出符合所提供的匹配模式或者匹配模式的数组的文件。 将返回一个文件流（stream）,它可以被输送（piped）到别的插件中。

	gulp.src('dist/js/*.js') // 匹配 'dist/js文件夹下所有的js文件'
**B) gulp.dest(path[, options])**   
将pipe进来的数据进行重新输出，可以pipe到多个文件夹，如果文件夹不存在的话将会自动创建。文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算

	.pipe(gulp.dest('build'))

**C) gulp.task(name[, deps], fn)**  
定义一个gulp任务。  
-- **name**： 任务的名字，避免名字中使用空格。  
-- **deps**： 可选。任务列表的数组，这些任务会在你当前任务运行之前完成。  
-- **fn**： 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：`gulp.src().pipe(someplugin())`  
 默认的，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事：
--给出一个提示，来告知 task 什么时候执行完毕，  
--并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。  

	var gulp = require('gulp');
	
	// 返回一个 callback，因此系统可以知道它什么时候完成
	gulp.task('one', function(cb) {
	    // 做一些事 -- 异步的或者其他的
	    cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了
	});
	
	// 定义一个所依赖的 task 必须在这个 task 执行之前完成
	gulp.task('two', ['one'], function() {
	    // 'one' 完成后
	});
	
	gulp.task('default', ['one', 'two']);
**D) gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])**   
监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。  
--**glob**：类型： String or Array。
  
--**tasks**: 类型： Array  

--**cb(event)**：类型： Function 
     
    //形式一：绑定监听事件。对特定文件，特定的gulp.task()任务
	var watcher = gulp.watch('js/**/*.js', ['scripts']);
	watcher.on('change', function(event) {
	  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
	}); 
    //形式二：回调函数。只对特定文件进行监听。
	gulp.watch('js/**/*.js', function(event) {
	  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
	}); 

**<font size="4" color="red" >三.</font>**   

**<font size="3" color="blue">3.1 </font>**  
 	
	gulp.src('dist/js/*.js') // 匹配 'dist/js文件夹下所有的js文件'

**<font size="3" color="blue">3.2 </font>**   

**<font size="3" color="blue">3.3 </font>**   

**<font size="3" color="blue">3.4 </font>**   
**A)** 

**B)**   
**<font size="4" color="red" >四. 标题4</font>**  
**<font size="3" color="blue">4.. 二级标题</font>**   
**A)** 

**B)**   
在Grunt里面，每个插件使用的方式相对独立，Gruntfile.js的配置相对繁琐。Grunt的插件就像独立的工厂，这个工厂生成出来的产品打包封装好后再送到另一个工厂去加工，使用了Gulp后实现了工厂的合并，所有东西都在一个工厂里完成了。而Gulp
</font>  
******

