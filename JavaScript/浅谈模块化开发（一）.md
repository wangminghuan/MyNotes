##<font face="微软雅黑">JS模块化开发之一

**<font size="4" color="red" >一. 模块化的概念</font>**  
模块就是实现特定功能的一组方法  

**<font size="3" color="blue">1.1 原生JS的几种“模块化”写法</font>**  

**A)原始写法**   

	function m1(){
	    console.log("module1")
	}
	function m2(){
	    console.log("module2")
	} 
使用的时候调用m1() 和 m2() 即可。但这种做法会污染全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。

**B)对象写法**  

	var modA = {
	        a:1,
	        b:2, //变量a、b外部不可见	
	        add : function(){
	            return modA.a+modA.b;
	        },
	        mult : function(){
	            return modA.a*modA.b;
	        },
	
	}
	console.log(modA.add());
	console.log(modA.mult())；

利用命名空间，写入一个全局对象，成为模块的入口。这样虽然看起来有模块是“型”，但对象中的所有成员都是对外暴露的，依旧存在被改写的可能。因此，我们更进一步，选用闭包（立即执行函数的一种）的写法。  

**C)立即执行函数写法**  

	var modA =(function() {
	    var a=1,b=2;//变量a、b外部不可见
	    return {
	       add : function(){
	           return a+b;
	       },
	       mult : function(){
	           return a*b;
	       }
	    }
	})();
	console.log(modA.add());
	console.log(modA.mult());

外部只能访问到add()和mult()另个方法，变量a和变量b不能被访问。利用自执行函数的特点，可以方便的为模块添加方法。称之为：放大模式。  

**D)放大模式**

	var modA =(function(mod) {
	    var a=1,b=2;//变量a、b外部不可见
	    mod.divide=function(){
	        return b-a;
	    };
	    return mod;
	})(modA||{}); //若modA在本代码执行前已定义则调用modeA,否则定义modeA为一个空对象，为modA添加一个方法；
	console.log(modA.divide());
模块的构建思想便是通过这样的方式逐渐演化而来，下面将通过介绍一些JS模块化编程的标准来展示如何组织，管理和编写模块。  

**<font size="4" color="red" >二. AMD和CMD</font>**  
在说AMD和CMD之前，先要提一下CommonJS：  
&emsp;&emsp;CommonJS是为了弥补JavaScript标准库过少的缺点而产生的，由于JS没有模块机制（ES6引入了模块系统），CommonJS就帮助JS实现模块的功能。现在很热门的Node.js就是CommonJS规范的一个实现。  
&emsp;&emsp;CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD和CMD 解决方案。  

**<font size="4" color="red">三.  ReuireJs (AMD)</font>**   
AMD 是 RequireJS 在推广过程中对模块定义的规范化产出的。  
 
RequireJS使用流程：  

**<font size="3" color="blue">3.1 引入</font>**  
 
HTML文件中引入requireJs文件，一般建议在body底部引入。  
	
	<script type="text/javascript" data-main="js/main" src="js/require.js"></script>  
**<font size="3" color="blue">3.2 入口文件</font>**  

类似c/c++中的main函数，页面中的js引入入口一般通过一个main.js文件来完成。requireJs支持`data-main` 方式引入main.js（IE7以下不支持自定义data属性）。属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。  

**A) require.config( )**:配置选项 

	require.config({ 		
        baseUlr:"js", 
        //所有模块的查找根路径。如未显式设置baseUrl，则默认值是加载require.js的HTML所处的位置。如果用了data-main属性，则该路径就变成baseUrl。
		
		paths:{
	     "jquery" : ["http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js", "js/jquery"], 
            //别名 : ['先加载1','备用地址1','备用地址2']
		}
	})
**B) require( )**的参数：  
&emsp;&emsp;--**所依赖的模块（可选）**：该模块名称可以是模块的路径（不要加'.js'）,也可以是`require.config`中配置的模块别名，但对于有主模块（就是定义了模块ID），paths中的别名必须和模块ID相同。  

&emsp;&emsp;--**回调函数**：参数名可以自定义。一般和依赖模块名中写入的相同。  

	require(["a","b","jquery"],function(a,b,$){
	  console.log("main.js 执行");
	   a.hello();
	  $("li").eq(0).click(function(){
	  	b.hello();
	  })
	})

**<font size="3" color="blue">3.3 定义模块</font>** 
 
**define(id?, dependencies?, factory)**;  
&emsp;&emsp;--**id(可选)**：自定义的模块ID名称，不写则为“无主模块”；   

&emsp;&emsp;--**dependencies(可选)**：定义的模块中所依赖的模块。  

&emsp;&emsp;--**factory**：工厂函数，
    
    //a.js
	define("a",["c"],function(c){
		console.log("a.js 执行");
		c.hello();
		function hello(){
			console.log("a.hello方法被调用")
		};
		return {
			hello:hello
		}
	}) 
	
    //b.js
	define(function(){
		console.log("b.js 执行");
		function hello(){
			console.log("b.hello方法被调用")
		};
		return {
			hello:hello
		}
	})
	//c.js
	define("c",[],function(){
		console.log("c.js 执行");
		function hello(){
			console.log("c.hello方法被调用")
		};
		return {
			hello:hello
		}
	})

**return** 对外提供模块接口。  

**<font size="3" color="blue">3.4 依赖一个不使用requirejs方式定义的模块</font>**   
配置require.config的**shim**参数：    

	require.config({
		baseUlr:"js",
		paths:{
	     "jquery" : ["http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min", "js/jquery"],
		 "comD":"d"
		},
		shim: { 
	     comD: { exports: 'hello1' } //把d当做无主模块对待即可，别名也可以通过paths配置。
	     }
	})
    require(["a","b","jquery","comD"],function(a,b,jquery,hello1){//方法名称作为参数
	  console.log("main.js 执行");
	  a.hello();
	  jquery("li").eq(0).click(function(){
	  	b.hello();
	  	hello1();
	  })
	})

利用exports只能暴露一个全局变量，如果需要暴露多个全局变量，则需要使用**init**   

	require.config({
		paths:{
	     "jquery" : ["http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min", "js/jquery"],
	     "comD":"d"
		},
		shim: {
	     comD:{  //此处配置方式的变化
	     	    init: function(){
	     	    	return {
	     	    		hello1:hello1,
	     	    		hello2:hello2
	     	    	}
	     	    }
	     	 }
	     }
	})  
	require(["a","b","jquery","comD"],function(a,b,jquery,comD){ //模块名称作为对象
	  console.log("main.js 执行");
	  a.hello();
	  jquery("li").eq(0).click(function(){
	  	b.hello();
	  	hello1();
	  	hello2();
	  })
	})
  
**<font size="3" color="blue">3.5 无主的与有主的模块 </font>**   
**A）**如果我们不指明模块名，就像这样：

	define([...], function() {
	  ...
	});
那么它就是无主的模块。我们可以在 requirejs.config 里，使用任意一个模块名来引用它。这样的话，就让我们的命名非常自由，大部分的模块就是无主的。

但是jquery等库都是有主的模块，为什么这么做？出于性能的考虑。因为像 jquery , underscore 这样的基础库，经常被其它的库依赖。如果声明为无主的，那么其它的库很可能起不同的模块名，这样当我们使用它们时，就可能会多次载入jquery/underscore。定为有主模块，所有模块就必须使用同一个名字来引用它。这样多次引用的方式就可以被避免。  

**B）**对于模块命名，以及引用加载的个人理解  
如果自己定义的模块ID与这个文件的名称不同，如："a.js"定义为"modA"，一定要在config的paths中将这个ID指向自己的文件: 

	require.config({
		paths:{
		"modA":"a",
		 }
	})
否则将会报错，简单起见，模块ID和文件名保持一致！！！  

关于require.config中的map此处不再介绍。  

**<font size="4" color="red">四. SeaJs(CMD)</font>**  
CMD相当于按需加载，定义一个模块的时候不需要立即制定依赖模块，在需要的时候require就可以了，比较方便；而AMD则相反，定义模块的时候需要制定依赖模块，并以形参的方式引入factory中。 
SeaJS使用流程：  

**<font size="3" color="blue">4.1 引入</font>**  
 
与requireJs相同，只是SeaJS新版已经取消了通过data-main的引入main.js。  
	
	<script type="text/javascript" src="js/require.js"></script>   
**<font size="3" color="blue">4.2 入口文件</font>**  
与requireJs不同，main.js通过seajs.use()方法引入模块。  
seajs.use([模块地址]，[回调函数]?)  
--回调函数接受引用模块exports对外输出的属性和方法。
  

    <script type="text/javascript">
	seajs.config({ //全局配置，与requireJS类似。
	    alias: {   //类似requireJs的paths
	      'main': 'main.js'
	    },
	});
	seajs.use("main",function(ex){
       console.log(ex.num);
      }); //use()方法引入入口文件。
	</script>  

**<font size="3" color="blue">4.3 定义模块</font>**     
同样通过define进行定义模块，回调函数里面的三个形参不能更改。

	define(function(require, exports, module){
	 //code
	}） 
我们可以定义三个模块：  

    //main.js
	var modeA=require("a.js"); //通过require引入依赖模块，返回值就是模块exports或return出来的对象；
	    modeA.hello();
	    var oLi=document.getElementsByTagName('li');
	    oLi[0].onclick=function(){
	    	var modeB=require("b.js");
	  	  modeB.hello();
	    }
	    exports.num=num; //对外提供的属性和方法可以挂载在exports下

    //a.js
	define(function(require, exports, module){
		console.log("a.js 执行");
		function hello(){
			console.log("a.hello方法被调用")
		};
		return {
			hello:hello  //对外提供的属性和方法可以使用return,同require一样
		}
	})

    //b.js
	define(function(require, exports, module){
		console.log("b.js 执行");
		function hello(){
			console.log("b.hello方法被调用")
		};
		module.exports.hello=hello;; //对外提供的属性和方法可以挂载在module.exports下
	})

**<font size="3" color="blue">4.4 与RequireJS的异同（个人总结）</font>**   
**A)**相同：通过define定义模块。
   
**B)**相同：通过config配置模块。  

**C)**不同：main.js的引入方式不同。  

**D)**不同：seajs中require（）只用于加载模块间的依赖，不用于main.js的引入。 

**E)**不同：模块加载机制不同，seajs是使用哪个引用哪个，不需要提前写好依赖。这样就可以避免一些还未执行到的模块就提前加载和运行（如例子中的b.js模块）。缺点是依赖不明了，不利于阅读。  
  
</font>  
******

